
# ----------------------------------------------------------------------------------- #
# SECTION 1:
# reading annotation to Granges
# makes GRanges object from a given bed6 or bed12 file to granges object

# SECTION 1: S3 functions

# extracts exons from a bed12 file and puts them into Granges object
# done in pure R
bed12.to.exons<-function(ref)
{
  #colClasses=c("factor","integer","integer","factor","integer","factor","integer","integer","integer","integer","factor","factor") 
  #ref         =read.table(bed.file,header=F,skip=skip,colClasses = colClasses,stringsAsFactors=F) # give colClasses for fast read-in
  ref=unique(ref)
  # apply strsplit on columns 11 and 12 to extract exon start positions and exon sizes
  b.start.size=cbind(as.integer(unlist(strsplit(as.character(ref$V12),"," ))),as.integer(unlist(strsplit(as.character(ref$V11),"," ))))
  rep.ref     =ref[rep(1:nrow(ref),ref[,10]),] # replicate rows occurs as many as its exon number
  #exon.id     =unlist(sapply(ref[,10],function(x) 1:x));rep.ref$V5=exon.id
  exon.id     =unlist( mapply( function(x,y) ifelse(x=="+",return(1:y),return(y:1) ),ref[,6],ref[,10]  ) );rep.ref$V5=exon.id

  rep.ref$V3  =rep.ref$V2+b.start.size[,1]+b.start.size[,2] # calculate exon start and ends
  rep.ref$V2  =rep.ref$V2+b.start.size[,1]
  
  #return(rep.ref[,1:6]) if you want to return as a data.frame

#  if(is.null(chrom.file))
#  {
    strands=as.character(rep.ref$V6)
    strands[strands=="."]="*"
    grange.exons=GRanges(seqnames=as.character(rep.ref$V1),
          ranges=IRanges(start=rep.ref$V2+1, end=rep.ref$V3),
          strand=strands, score=rep.ref$V5,name=rep.ref$V4)
    return(grange.exons)
#  }
  
#  #read table for chromosome info
#  chrom=read.table(chrom.file,header=F)
#  chrom=chrom[chrom[,1] %in% rep.ref$V1,1:2]
#  seqlengths=chrom[,2];names(seqlengths)=as.character(chrom[,1])
  # do adjustments so that trans and exons have the same numerical id
#  strands=as.character(rep.ref$V6)
#  strands[strands=="."]="*"
#  grange.exons=GRanges(seqnames=as.character(rep.ref$V1),
#          ranges=IRanges(start=rep.ref$V2+1, end=rep.ref$V3),
#          strand=strands, score=rep.ref$V5,name=rep.ref$V4,seqlengths=seqlengths)
#  return(grange.exons)

} 

# extracts exons from a bed12 file and puts them into Granges object
# done in pure R
bed12.to.introns<-function(ref)
{
  #colClasses=c("factor","integer","integer","factor","integer","factor","integer","integer","integer","integer","factor","factor") 
  #ref         =read.table(bed.file,header=F,skip=skip,colClasses = colClasses,stringsAsFactors=F) # give colClasses for fast read-in

  #remove the genes with one exon only (they won't have any introns)
  ref=ref[ref[,10]>1,]
  ids=paste(ref[,1],ref[,2],ref[,3],ref[,4],sep="")
  ref=cbind(ref,id=ids)
  ref=unique(ref)
  # apply strsplit on columns 11 and 12 to extract exon start positions and exon sizes
  b.start.size=cbind(as.integer(unlist(strsplit(as.character(ref$V12),"," ))),as.integer(unlist(strsplit(as.character(ref$V11),"," ))))
  rep.ref     =ref[rep(1:nrow(ref),ref[,10]),] # replicate rows occurs as many as its exon number
  #exon.id     =unlist(sapply(ref[,10],function(x) 1:x));rep.ref$V5=exon.id
  exon.id     =unlist( mapply( function(x,y) ifelse(x=="+",return(1:y),return(y:1) ),ref[,6],ref[,10]  ) );rep.ref$V5=exon.id
  rep.ref$V3  =rep.ref$V2+b.start.size[,1]+b.start.size[,2] # calculate exon start and ends
  rep.ref$V2  =rep.ref$V2+b.start.size[,1]
  rep.ref     =rep.ref[,c(1:6,13)]
  
  # now try to get the exons by cbinding consecutive exons
  temp.ref    =cbind(rep.ref[1:(nrow(rep.ref)-1),],rep.ref[2:nrow(rep.ref),])
  temp.ref    =temp.ref[temp.ref[,7]==temp.ref[,14],]
  temp.ref[,2]=temp.ref[,3]
  temp.ref[,3]=temp.ref[,9]
  rep.ref     =temp.ref[,1:6]
  rep.ref[rep.ref[,6]=="-",5]=rep.ref[rep.ref[,6]=="-",5]-1 # subtract 1 from - strand exon numbers
    
#  if(is.null(chrom.file))
#  {
    strands=as.character(rep.ref$V6)
    strands[strands=="."]="*"
    grange.exons=GRanges(seqnames=as.character(rep.ref$V1),
          ranges=IRanges(start=rep.ref$V2+1, end=rep.ref$V3),
          strand=strands, score=rep.ref$V5,name=rep.ref$V4)
    return(grange.exons)
#  }
  
#  #read table for chromosome info
#  chrom=read.table(chrom.file,header=F)
#  chrom=chrom[chrom[,1] %in% rep.ref$V1,1:2]
#  seqlengths=chrom[,2];names(seqlengths)=as.character(chrom[,1])
#  # do adjustments so that trans and exons have the same numerical id
#  strands=as.character(rep.ref$V6)
#  strands[strands=="."]="*"
#  grange.exons=GRanges(seqnames=as.character(rep.ref$V1),
#          ranges=IRanges(start=rep.ref$V2+1, end=rep.ref$V3),
#          strand=strands, score=rep.ref$V5,name=rep.ref$V4,seqlengths=seqlengths)
#  return(grange.exons)

} 

# checks the validity of the bed data.frame if it is a legitimate bed columns
check.bed.validity<-function(bed.df,type="none")
{
  # does it have at least 3 columns
  num.col=(ncol(bed.df)>=3)
  
  # does it have 1st and 2nd column as numbers
  col1.2= (is.integer(bed.df[,2]) & is.integer(bed.df[,3]) )
  
  # does it have chr string in 1st column
  chr= sum(grepl("chr",bed.df[,1]) )

  if(type=="exons" | type=="introns")
  {
    #does it have 12>= columns
    ex=(ncol(bed.df)>=12) 
    
    return(num.col & col1.2 & chr & ex)
  }
  return(num.col & col1.2 & chr )

}

# ----------------------------------------------------------------------------------- #

# SECTION 1: S4 functions


# convert a data frame read-in from a bed file to a Granges object
setGeneric("convert.bed.df",function(bed) standardGeneric("convert.bed.df"))
setMethod("convert.bed.df" ,signature(bed = "data.frame" ),
                            function(bed){
                              
                            if(! check.bed.validity(bed)){stop("this is not a valid bed file")}
                            if(ncol(bed)>=6){
                              # check if 6th column is really strand
                              if( sum( unique(bed[,6]) %in% c("+","-",".") ) != length(unique(bed[,6])) ){stop("Strand column of the bed file or data.frame is wrong")}
                              #convert to granges
                              strands=as.character(bed$V6)
                              strands[strands=="."]="*"
                              grange=GRanges(seqnames=as.character(bed$V1),
                                            ranges=IRanges(start=bed$V2+1, end=bed$V3),
                                            strand=strands, score=bed$V5,name=bed$V4)
                            }
                            if(ncol(bed)==5){
                              grange=GRanges(seqnames=bed$V1,ranges=IRanges(start=bed$V2+1, end=bed$V3),strand=rep("*",nrow(bed)), score=bed$V5,name=bed$V4 )
                            }
                            if(ncol(bed)==4){
                              grange=GRanges(seqnames=bed$V1,ranges=IRanges(start=bed$V2+1, end=bed$V3),strand=rep("*",nrow(bed)),name=bed$V4)
                            }    
                            if(ncol(bed)==3){
                              grange=GRanges(seqnames=bed$V1,ranges=IRanges(start=bed$V2+1, end=bed$V3),strand=rep("*",nrow(bed)))
                            }                           
                            return(grange)
})

# convert a data frame read-in from a bed file to a Granges object for exons
setGeneric("convert.bed2exons",function(bed.df) standardGeneric("convert.bed2exons"))
setMethod("convert.bed2exons" ,signature(bed.df = "data.frame" ),
                            function(bed.df){
                              
                            if(! check.bed.validity(bed.df,"exon")){stop("this is not a valid bed file")}
                            bed12.to.exons(bed.df)
})

# convert a data frame read-in from a bed file to a Granges object for introns
setGeneric("convert.bed2introns",function(bed.df) standardGeneric("convert.bed2introns"))
setMethod("convert.bed2introns" ,signature(bed.df = "data.frame" ),
                            function(bed.df){
                              
                            if(! check.bed.validity(bed.df,"exon")){stop("this is not a valid bed file")}                      
                            bed12.to.introns(bed.df)
})


# read a bed file and convert it to GRanges
# arguments:
# location: location of the file
# remove.unsual  : remove the chromomesomes with unsual names, mainly random chromsomes etc
# DETAILS: one bed track per file is only accepted, the bed files with multiple tracks will cause en error
setGeneric("read.bed", function(location,remove.unsual=T) standardGeneric("read.bed"))
setMethod("read.bed", signature(location = "character"),#remove.unsual="logical" ),
                    function(location,remove.unsual){
                    
                    # find out if there is a header, skip 1st line if there is a header
                    f.line=readLines(con = location, n = 1)
                    skip=0
                    if(grepl("^track",f.line))(skip=1)
                    
                    # read bed6
                    bed=.readTableFast(location,header=F,skip=skip)                    
                    if(remove.unsual){ bed=bed[grep("_", as.character(bed[,1]),invert=T),] }
                    convert.bed.df(bed)
                    
})

# function reading exon intron, promoter structure from a given bed file
# ARGUMENTS      :
# location       : location of the bed file with 12 or more columns
# remove.unsual  : remove the chromomesomes with unsual names, mainly random chromsomes etc
# up.flank       : up-stream from TSS to detect promoter boundaries
# down.flank     : down-stream from TSS to detect promoter boundaries
# unique.prom    : get only the unique promoters, promoter boundaries will not have a gene name if you set this option to be TRUE
# DETAILS: one bed track per file is only accepted, the bed files with multiple tracks will cause en error
setGeneric("read.transcript.features", function(location,remove.unsual=T,up.flank=1000,down.flank=1000,unique.prom=T) standardGeneric("read.transcript.features"))
setMethod("read.transcript.features", signature(location = "character"),#,remove.unsual="logical",up.flank="numeric",down.flank="numeric",unique.prom="logical" ),
                    function(location,remove.unsual,up.flank ,down.flank ,unique.prom){
                      
                    # find out if there is a header, skip 1st line if there is a header
                    f.line=readLines(con = location, n = 1)
                    skip=0
                    if(grepl("^track",f.line))(skip=1)
                    
                    # read bed6
                    bed=.readTableFast(location,header=F,skip=skip)                    
                    if(remove.unsual){ bed=bed[grep("_", as.character(bed[,1]),invert=T),] }
                    
                    introns=bed12.to.introns(bed)
                    exons  =bed12.to.exons(bed)
                    
                    # get the locations of TSSes
                    tss=bed
                    #  + strand
                    tss[tss$V6=="+",3]=tss[tss$V6=="+",2]
                  
                    #  - strand
                    tss[tss$V6=="-",2]=tss[tss$V6=="-",3]
                    tssg=GRanges(seqnames=as.character(tss$V1),
                            ranges=IRanges(start=tss$V2, end=tss$V3),
                            strand=as.character(tss$V6),score=rep(0,nrow(tss)),name=tss$V4)
                    
                    # get the locations of promoters
                    #  + strand
                    bed[bed$V6=="+",3]=bed[bed$V6=="+",2]+down.flank
                    bed[bed$V6=="+",2]=bed[bed$V6=="+",2]-up.flank
                  
                    #  - strand
                    bed[bed$V6=="-",2]=bed[bed$V6=="-",3]-down.flank
                    bed[bed$V6=="-",3]=bed[bed$V6=="-",3]+up.flank
                    
                    if(! unique.prom)
                    {
                      prom.df=(bed[,c(1,2,3,4,6)])
                      prom=GRanges(seqnames=as.character(prom.df$V1),
                            ranges=IRanges(start=prom.df$V2, end=prom.df$V3),
                            strand=as.character(prom.df$V6),score=rep(0,nrow(prom.df)),name=prom.df$V4)
                    }else{
                      prom.df=unique(bed[,c(1,2,3,6)])
                      prom=GRanges(seqnames=as.character(prom.df$V1),
                            ranges=IRanges(start=prom.df$V2, end=prom.df$V3),
                            strand=as.character(prom.df$V6),score=rep(0,nrow(prom.df)),name=rep(".",nrow(prom.df)) )
                      
                    }
                  
                    GRangesList(exons=exons,introns=introns,promoters=prom,TSSes=tssg)
})

# a function to get upstream and downstream adjecent regions to a genomic feature such as CpG islands
# ARGUMENTS:
# GRanges object for the feature
# flank: number of basepairs for the flanking regions
# clean: If set to TRUE, flanks overlapping with other main features will be trimmed, and overlapping flanks will be removed
#        this will remove multiple counts when other features overlap with flanks
setGeneric("getFlanks", function(grange,flank=2000,clean=T) standardGeneric("getFlanks"))
setMethod("getFlanks", signature(grange= "GRanges"),
                    function(grange,flank=2000,clean=T){
          
                    shores=c( flank(grange,flank),flank(grange,flank,FALSE) )
                    shores=reduce(setdiff(shores, grange)) # ,erge overlapping shores remove CpG coordinates from all shores, das ist so cool!!
                    shores
})

# a function to read-in genomic features and their upstream and downstream adjecent regions such as CpG islands and their shores
# ARGUMENTS:
# location: for the bed file of the feature 
# flank   : number of basepairs for the flanking regions
# clean   : If set to TRUE, flanks overlapping with other main features will be trimmed
# VALUE   :
# a GRangesList contatining one GRanges object for flanks and one for GRanges object for the main feature
setGeneric("read.feature.flank", function(location,remove.unsual=T,flank=2000,clean=T) standardGeneric("read.feature.flank") )
setMethod("read.feature.flank", signature(location = "character"),
                    function(location,remove.unsual,flank ,clean){
                    feat=read.bed(location,remove.unsual)
                    flanks=getFlanks(feat,flank=flank,clean=clean)
                    list(features=feat,flanks=flanks)
})

# SECTION 2:
# annotate granges objects with annotations that read-in and converted to Granges objects


# A set of objects that will hold statistics about feature and annotation overlap
setClass("annotationByFeature", representation(members         ="matrix",
                                      annotation      ="numeric",
                                      hierarchical    ="numeric",
                                      num.annotation  ="numeric",
                                      num.hierarchical="numeric",
                                      no.of.OlapFeat  ="numeric",
                                      perc.of.OlapFeat="numeric"))

setClass("annotationByGenicParts", representation(dist.to.TSS   ="matrix"),contains="annotationByFeature")


#new.obj=new("annotationByGenicParts",
#            members=matrix(c(1,2,3,4)),annotation=c(1,2,0,3,4),
#            hierarchical=c(a=1,b=2,c=0,d=3,e=4),
#            num.annotation  =c(1,2,0,3,4),
#            num.hierarchical=c(1,2,0,3,4),
#            no.of.OlapFeat  =c(1,2,0,3,4),
#            perc.of.OlapFeat=c(1,2,0,3,4),
#            dist.to.TSS     =c(1,2,0,3,4) )
                                    

setMethod("show", "annotationByGenicParts", function(object) {
  
  cat("summary of annotation object with","rows\n--------------\n")
  cat("--------------\n")
  cat("percentage of features overlapping with annotation :\n");print(object@annotation);cat("\n\n")
  cat("percentage of features overlapping with annotation (with promoter>exon>intron precedence) :\n"); print(object@hierarchical) ;cat("\n\n")
  cat("percentage of annotation boundaries with feature overlap :\n");print(object@perc.of.OlapFeat;cat("\n\n")  
  cat("summary of distances to the nearest TSS :\n")
  print(summary(abs(object@dist.to.TSS[,2])))
})


# SECTION 2: S3 FUNCTIONS 
# these shouldn't be exported

annotate.gr.WithGenicParts<-function(gr,prom,exon,intron,strand=F)
{
  if( ! strand){strand(gr)="*"}
  memb=data.frame(matrix(rep(0,length(gr)*3),ncol=3) )  ;colnames(memb)=c("prom","exon","intron")
  memb[countOverlaps(gr,prom)>0,1]=1
  memb[countOverlaps(gr,exon)>0,2]=1
  memb[countOverlaps(gr,intron)>0,3]=1

  annotation=c(promoter  =100*sum(memb$prom>0)/nrow(memb) ,
               exon      =100*sum(memb$exon>0)/nrow(memb) ,
               intron    =100*sum(memb$intron>0)/nrow(memb) ,
               intergenic=100*sum(rowSums(memb)==0)/nrow(memb) )
  
  num.annotation=c( promoter  =sum(memb$prom>0) ,
                    exon      =sum(memb$exon>0) ,
                    intron    =sum(memb$intron>0) ,
                    intergenic=sum(rowSums(memb)==0) )

  hierarchical=c(promoter  =100*sum(memb$prom>0)/nrow(memb) ,
               exon      =100*sum(memb$exon>0 & memb$prom==0)/nrow(memb) ,
               intron    =100*sum(memb$intron>0 & memb$exon==0 & memb$prom==0)/nrow(memb) ,
               intergenic=100*sum(rowSums(memb)==0)/nrow(memb) )

  num.hierarchical=c( promoter  =sum(memb$prom>0) ,
                      exon      =sum(memb$exon>0 & memb$prom==0),
                      intron    =sum(memb$intron>0 & memb$exon==0 & memb$prom==0) ,
                      intergenic=sum(rowSums(memb)==0) )  
  
  numberOfOlapFeat=c(promoter=sum(countOverlaps(prom,gr)>0),
    exon=sum(countOverlaps(exon,gr)>0),
    intron=sum(countOverlaps(intron,gr)>0) )
  percOfOlapFeat =100*numberOfOlapFeat/c(length(prom),length(exon),length(intron))
  return(list(members=memb,annotation=annotation,hierarchical=hierarchical,num.annotation=num.annotation,
              num.hierarchical=num.hierarchical,
              numberOfOlapFeat=numberOfOlapFeat,percOfOlapFeat=percOfOlapFeat) )
  
}

distance2TSS<-function(g.idh,tss)
{
  
  elementMetadata(g.idh)=DataFrame(elementMetadata(g.idh),orig.row=1:length(g.idh))
  id.col=ncol(elementMetadata(g.idh)+5
  met.tss= .nearest.2bed(g.idh, tss)

  dist.col=ncol(met.tss)
  met.tss[met.tss$end<met.tss$start.y & met.tss$strand.y=="+",dist.col] = -1* met.tss[met.tss$end<met.tss$start.y & met.tss$strand.y=="+",dist.col]

  met.tss[met.tss$end>met.tss$start.y & met.tss$strand.y=="-",dist.col] = -1* met.tss[met.tss$end>met.tss$start.y & met.tss$strand.y=="-",dist.col]

  res=met.tss[order(met.tss[,id.col]),c(id.col,dist.col)]
  return(res)
}


# get the nearest features between a subject and query bed file
# get grange objects in bed zormat
# g.bed is GenomicRanges object, biatch!!!
# subject is also GenomicRanges object
.nearest.2bed<-function(g.bed,subject)
{
  chrs1=levels(seqnames(g.bed))
  chrs2=levels(seqnames(subject))
  chrs=chrs1[chrs1 %in% chrs2]
  res.df=NULL
  for(i in 1:length(chrs))
  {
    # find the nearest for this range
    ind  =nearest(ranges(g.bed[seqnames(g.bed)==chrs[i],]),ranges(subject[seqnames(subject)==chrs[i],]))
    sbdf1 =as.data.frame(g.bed[seqnames(g.bed)==chrs[i],] )
    sbdf2 =as.data.frame(subject[seqnames(subject)==chrs[i],] )[ind,]
    names(sbdf2)=paste(names(sbdf2),".y",sep="")
    temp  =cbind(sbdf1,sbdf2)
    res.df=rbind(res.df,temp)
  }

  res.dist=rep(0,nrow(res.df))
  dist1=abs(res.df$start-res.df$end.y)+1
  dist2=abs(res.df$start.y-res.df$end)+1
  totti=res.df$width + res.df$width.y #total length
  res.dist[pmax(dist1,dist2)>totti]=pmin(dist1,dist2)[pmax(dist1, dist2) > totti] 
  res.df=cbind(res.df,dist=res.dist)
  return(res.df)
}


# function to annotate given GRanges object with promoter,exon,intron & intergenic values
setGeneric("annotate.WithGenicParts", function(GRanges.obj,GRangesList.obj,strand=F) standardGeneric("annotate.WithGenicParts") )
setMethod("annotate.WithGenicParts", signature(GRanges.obj = "GRanges",GRangesList.obj="GRangesList"),
                    function(GRanges.obj,GRangesList.obj,strand=F){
                      
                      a.list      =annotate.gr.WithGenicParts(GRanges.obj,GRangesList.obj$promoters,GRangesList.obj$exons,GRangesList.obj$introns,strand=strand)
                      distance2TSS=GRanges.obj,GRangesList.obj$TSSes)

                      new("annotationByGenicParts",
                                  members         =as.matrix(a.list$members),
                                  annotation=a.list$annotation,
                                  hierarchical    =a.list$hierarchical,
                                  num.annotation  =a.list$num.annotation,
                                  num.hierarchical=a.list$num.hierarchical,
                                  no.of.OlapFeat  =a.list$no.of.OlapFeat,
                                  perc.of.OlapFeat=a.list$perc.of.OlapFeat,
                                  dist.to.TSS     =as.matrix(distance2TSS) )
})






# SECTION 3:
# annotate my objects with annotations read-in and converted to Granges objects
